<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Moodboard Studio</title>
  <link rel="icon" type="image/svg+xml" href="../favicon.svg" />
  <script>
    (function () {
      try {
        let theme = localStorage.getItem('creative-toolkit-theme') || 'system';
        if (theme === 'system') {
          theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }
        document.documentElement.dataset.theme = theme;
      } catch (e) { }
    })();
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <link rel="stylesheet" href="../shared/styles.css" />
  <style>
    /* === MOODBOARDS-SPECIFIC STYLES === */

    /* Header grid positioning */
    header.panel {
      grid-column: 1 / -1;
    }

    /* Aside controls sticky */
    aside.panel.controls {
      position: sticky;
      top: 0;
      max-height: 100%;
      overflow-y: auto;
    }

    /* Main panel with drag-over state */
    main.panel {
      padding: var(--space-5);
      min-height: 0;
      overflow-y: auto;
      transition: border-color 0.2s ease;
    }

    main.panel.drag-over {
      border-color: var(--accent-color);
      background-color: var(--accent-color-tint);
    }

    /* Color palette circles */
    #color-palette {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
    }

    .color-circle {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--border-color);
      transition: transform 0.2s ease;
    }

    .color-circle:hover {
      transform: scale(1.1);
    }

    /* Logo upload zone */
    .logo-upload {
      width: 100%;
      height: 60px;
      border: 2px dashed var(--border-color);
      border-radius: var(--radius-md);
      background-color: var(--surface);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--muted);
      overflow: hidden;
    }

    .logo-upload img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    /* Moodboard canvas - masonry layout using CSS Grid */
    #moodboard-canvas {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      column-gap: var(--space-4);
      row-gap: 0;
      /* aligned with 1px grid rows */
      grid-auto-rows: 1px;
      align-items: start;
    }

    @media (max-width: 600px) {
      #moodboard-canvas {
        grid-template-columns: 1fr;
      }
    }

    /* Moodboard card */
    .moodboard-card {
      display: block;
      width: 100%;
      position: relative;
      cursor: grab;
      background-color: var(--surface);
      border-radius: var(--radius-md);
      overflow: hidden;
      margin-bottom: var(--space-4);
      /* needed for visual gap in 1px grid */
    }

    .moodboard-card.dragging {
      opacity: 0.5;
    }

    .moodboard-card img {
      width: 100%;
      height: auto;
      display: block;
      border-radius: var(--radius-md);
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .moodboard-card img.loaded {
      opacity: 1;
    }

    /* Card spinner */
    .moodboard-card .spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30px;
      height: 30px;
      border: 3px solid var(--accent-color-tint);
      border-top-color: var(--accent-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: translate(-50%, -50%) rotate(360deg);
      }
    }

    /* Delete button on hover */
    .moodboard-card:hover .delete-btn {
      opacity: 1;
    }

    /* Add card button */
    .add-card-btn {
      width: 100%;
      padding: var(--space-5) 0;
      border: 2px dashed var(--border-color);
      border-radius: var(--radius-md);
      background-color: var(--surface);
      color: var(--muted);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      margin-bottom: var(--space-4);
      /* needed for visual gap in 1px grid */
      display: flex;
      justify-content: center;
      align-items: center;
      height: 200px;
      /* Explicit height */
    }

    /* Delete button */
    .delete-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: grid;
      place-items: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity var(--duration-standard);
    }

    /* Color picker modal */
    .modal-content {
      background: var(--surface-alt);
      padding: var(--space-5);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-floating-3);
      width: 90%;
      max-width: 300px;
      border: 1px solid var(--border-color);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-4);
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.2rem;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: var(--space-3);
      margin-top: var(--space-4);
    }

    /* Color picker body */
    #color-picker-body {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-4);
    }

    #color-picker-native {
      width: 150px;
      height: 150px;
      border: none;
      padding: 0;
      background: none;
      cursor: pointer;
    }

    #color-picker-native::-webkit-color-swatch-wrapper {
      padding: 0;
    }

    #color-picker-native::-webkit-color-swatch {
      border-radius: 50%;
      border: 1px solid var(--border-color);
    }

    #color-picker-native::-moz-color-swatch {
      border-radius: 50%;
      border: 1px solid var(--border-color);
    }

    /* Hex input */
    .hex-input {
      font-family: var(--font-family-mono);
      text-align: center;
      text-transform: uppercase;
    }

    /* Wiki header background */
    .wiki-header {
      background-image: url('modal.png');
    }
  </style>
</head>

<body>
  <div class="splash-overlay" id="splash-screen">
    <div class="splash-content">
      <button id="splash-close-btn" title="Close">&times;</button>
      <div class="splash-info">
        <span class="splash-icon">üñºÔ∏è</span>
        <h2 class="splash-title">Moodboard Studio</h2>
        <p class="splash-tech">Visualizes ideas and concepts using html2canvas for exports and a client-side color
          palette generator.</p>
        <p class="splash-credits">2025. Toolkit by e</p>
        <label class="splash-dont-show">
          <input type="checkbox" id="splash-dont-show-checkbox">
          Don't show again
        </label>
      </div>
      <div class="splash-image">
        <img src="modal.png" alt="Moodboard Studio Splash Image">
      </div>
    </div>
  </div>

  <div class="container loading" id="app-container">
    <header class="panel">
      <a href="../index.html" class="back-to-home" title="Return to Home">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5"
          stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
        </svg>
      </a>
      <h1>Moodboard Studio</h1>
      <div class="sub">Create and export beautiful, inspiring moodboards.</div>
      <div class="theme-switcher">
        <button id="wiki-open-btn" title="Info">‚ìò</button>
        <button id="theme-toggle" title="Change theme"></button>
      </div>
    </header>

    <aside class="panel controls" id="controls">
      <div class="control-group">
        <div class="form-group">
          <label for="logo-input">Logo</label>
          <div class="logo-upload" id="logo-upload-container">
            <span>Upload Logo</span>
            <input type="file" id="logo-input" accept="image/*" style="display:none;">
          </div>
        </div>
      </div>
      <div class="control-group">
        <div class="form-group">
          <label for="board-title">Client</label>
          <input type="text" id="board-title" class="form-control" value="My Project Inspiration">
        </div>
      </div>
      <div class="control-group">
        <div class="form-group">
          <label>Auto-Generated Palette</label>
          <div id="color-palette"></div>
        </div>
      </div>
      <div class="control-group" style="margin-top: auto;">
        <button id="reset-btn" class="btn btn-secondary">Reset</button>
      </div>
      <div class="control-group">
        <button id="export-btn" class="btn btn-primary">Download</button>
      </div>
      <div class="note">Tip: Drag images onto the main panel to add them. The color palette will update automatically.
      </div>
    </aside>

    <main class="panel" id="main-panel">
      <div id="moodboard-canvas">
        <div class="add-card-btn" id="add-card-btn" onclick="document.getElementById('file-input').click()">+</div>
      </div>
    </main>
  </div>

  <div class="popup-overlay" id="color-picker-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Edit Color</h2>
      </div>
      <div class="modal-body" id="color-picker-body">
        <input type="color" id="color-picker-native">
        <input type="text" id="color-picker-hex" class="form-control hex-input">
      </div>
      <div class="modal-footer">
        <button id="cancel-color-btn" class="btn btn-secondary">Cancel</button>
        <button id="save-color-btn" class="btn btn-primary">Save</button>
      </div>
    </div>
  </div>

  <div id="wiki-overlay" class="popup-overlay"></div>

  <script type="module">
    const WIKI_DATA = {
      "title": "Moodboard Studio Info",
      "sections": [
        {
          "title": "How to Use",
          "content": [
            "<b>1. Add Content:</b> Click the '+' button or drag images directly onto the main canvas to add them to your moodboard.",
            "<b>2. Customize Branding:</b> Upload a client's logo and edit the project title in the sidebar.",
            "<b>3. Automatic Palette:</b> As you add images, the app analyzes them and automatically generates a representative color palette.",
            "<b>4. Download:</b> Click the 'Download' button to export your complete moodboard as a high-quality PNG, perfect for sharing."
          ]
        },
        {
          "title": "Features",
          "content": [
            "<b>Instant Feedback:</b> Images appear on the board instantly while they load, making the app feel fast and responsive.",
            "<b>Smart Color Extraction:</b> A client-side algorithm finds the most dominant and relevant colors from your images to build a cohesive palette.",
            "<b>Drag & Drop:</b> Easily reorder images on the canvas by dragging them into a new position.",
            "<b>Local & Private:</b> All your images and data are processed in your browser. Nothing is ever uploaded to a server."
          ]
        }
      ]
    };

    const App = {
      el: {},
      state: {
        title: "My Project Inspiration",
        colors: [],
        logo: null,
        images: [],
        splashHidden: false,
        isWikiLoaded: false
      },
      currentColorIndex: null,
      draggedItemId: null,
      THEMES: ['light', 'dark', 'system'],
      THEME_ICONS: { light: '‚òÄÔ∏è', dark: 'üåî', system: '‚öôÔ∏è' },

      init() {
        this.cacheDOMElements();
        this.initTheme();
        this.checkSplashPreference();
        this.loadState();
        this.bindEvents();
        // Initial resize for masonry
        window.addEventListener('resize', this.debounce(() => this.resizeAllMasonryItems(), 100));
        this.render();
      },

      debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      },

      hideSplashScreen(dontShowAgain = false) {
        if (!this.state.splashHidden) {
          this.state.splashHidden = true;
          this.el.splashScreen.classList.add('hidden');
          this.el.appContainer.classList.remove('loading');
          if (dontShowAgain) {
            localStorage.setItem('moodboards-splash-hidden', 'true');
          }
        }
      },

      checkSplashPreference() {
        if (localStorage.getItem('moodboards-splash-hidden') === 'true') {
          this.state.splashHidden = true;
          this.el.splashScreen.classList.add('hidden');
          this.el.appContainer.classList.remove('loading');
        }
      },

      cacheDOMElements() {
        const ids = [
          'theme-toggle', 'wiki-open-btn', 'board-title', 'color-palette',
          'logo-upload-container', 'logo-input', 'export-btn', 'reset-btn',
          'main-panel', 'moodboard-canvas', 'add-card-btn', 'splash-screen',
          'app-container', 'splash-close-btn', 'wiki-overlay',
          'color-picker-modal', 'color-picker-native', 'color-picker-hex', 'cancel-color-btn', 'save-color-btn'
        ];
        ids.forEach(id => {
          const key = id.replace(/-(\w)/g, (_, char) => char.toUpperCase());
          this.el[key] = document.getElementById(id);
        });
      },

      bindEvents() {
        this.el.themeToggle.addEventListener('click', () => this.cycleTheme());
        this.el.wikiOpenBtn.addEventListener('click', () => this.openWiki());

        this.el.splashScreen.addEventListener('click', (e) => {
          if (e.target === this.el.splashScreen) {
            const checkbox = document.getElementById('splash-dont-show-checkbox');
            this.hideSplashScreen(checkbox?.checked || false);
          }
        });
        this.el.splashCloseBtn.addEventListener('click', () => {
          const checkbox = document.getElementById('splash-dont-show-checkbox');
          this.hideSplashScreen(checkbox?.checked || false);
        });

        this.el.boardTitle.addEventListener('change', () => this.saveAndRender());
        this.el.logoInput.addEventListener('change', (e) => this.handleFileUploads(e.target.files, true));
        this.el.logoUploadContainer.addEventListener('click', () => this.el.logoInput.click());
        this.el.addCardBtn.addEventListener('click', () => this.addImage());
        this.el.moodboardCanvas.addEventListener('click', (e) => {
          if (e.target.closest('.delete-btn')) {
            const card = e.target.closest('.moodboard-card');
            if (card) this.removeImage(card.dataset.id);
          }
        });
        this.el.resetBtn.addEventListener('click', () => this.resetState());
        this.el.exportBtn.addEventListener('click', (e) => this.exportToImage(e.target));
        this.el.mainPanel.addEventListener('dragover', (e) => this.handleDragOver(e));
        this.el.mainPanel.addEventListener('dragleave', (e) => this.handleDragLeave(e));
        this.el.mainPanel.addEventListener('drop', (e) => this.handleFileDrop(e));
        this.el.colorPalette.addEventListener('click', e => {
          const circle = e.target.closest('.color-circle');
          if (circle) this.openColorPickerModal(parseInt(circle.dataset.index, 10));
        });
        this.el.saveColorBtn.addEventListener('click', () => this.saveColorFromModal());
        this.el.cancelColorBtn.addEventListener('click', () => this.closeModal('colorPickerModal'));
        this.el.colorPickerModal.addEventListener('click', (e) => { if (e.target === this.el.colorPickerModal) this.closeModal('colorPickerModal'); });
        this.el.colorPickerNative.addEventListener('input', () => this.syncColorInputs('native'));
        this.el.colorPickerHex.addEventListener('input', () => this.syncColorInputs('hex'));
      },

      saveAndRender() {
        this.saveState();
        this.render();
      },

      saveState() {
        const stateToSave = {
          title: this.el.boardTitle.value,
          colors: this.state.colors,
          logo: this.state.logo,
        };
        localStorage.setItem('moodboardState_v3', JSON.stringify(stateToSave));
      },

      loadState() {
        const savedState = localStorage.getItem('moodboardState_v3');
        if (savedState) {
          try {
            const loaded = JSON.parse(savedState);
            this.state.title = loaded.title || "My Project Inspiration";
            this.state.colors = loaded.colors || [];
            this.state.logo = loaded.logo || null;
          } catch (e) {
            console.error("Could not parse saved state, resetting.", e);
            localStorage.removeItem('moodboardState_v3');
          }
        }
      },

      resetState() {
        if (confirm('Are you sure you want to clear the entire moodboard?')) {
          this.state = {
            ...this.state,
            title: "My Project Inspiration",
            colors: [],
            logo: null,
            images: []
          };
          localStorage.removeItem('moodboardState_v3');
          this.saveAndRender();
        }
      },

      render() {
        this.el.boardTitle.value = this.state.title;

        this.el.colorPalette.innerHTML = '';
        this.state.colors.forEach((color, index) => {
          const circle = document.createElement('div');
          circle.className = 'color-circle';
          circle.style.backgroundColor = color;
          circle.title = `Edit ${color}`;
          circle.dataset.index = index;
          this.el.colorPalette.appendChild(circle);
        });

        this.el.logoUploadContainer.innerHTML = this.state.logo ? `<img src="${this.state.logo}" alt="Client Logo">` : `<span>Upload Logo</span>`;

        const canvas = this.el.moodboardCanvas;
        const existingCardIds = new Set(Array.from(canvas.children).map(c => c.dataset.id));
        const stateImageIds = new Set(this.state.images.map(i => i.id.toString()));
        existingCardIds.forEach(id => {
          if (!stateImageIds.has(id)) {
            canvas.querySelector(`[data-id="${id}"]`)?.remove();
          }
        });

        this.state.images.forEach(image => {
          let card = canvas.querySelector(`[data-id="${image.id}"]`);
          if (!card) {
            card = this.createImageCard(image);
            canvas.appendChild(card);
          }
        });
      },

      createImageCard(image) {
        const card = document.createElement('div');
        card.className = 'moodboard-card';
        card.dataset.id = image.id;
        card.draggable = true;

        card.addEventListener('dragstart', (e) => this.handleItemDragStart(e));
        card.addEventListener('dragend', (e) => this.handleItemDragEnd(e));
        card.addEventListener('dragover', (e) => this.handleItemDragOver(e));
        card.addEventListener('drop', (e) => this.handleItemDrop(e));

        const spinner = document.createElement('div');
        spinner.className = 'spinner';

        const img = new Image();
        // Removed crossOrigin = "anonymous" to prevent issues with Data URLs
        img.src = image.src;
        img.alt = "Moodboard image";
        img.onload = () => {
          spinner.remove();
          img.classList.add('loaded');
          // Calculate masonry row span based on image height
          this.resizeMasonryItem(card);
        };

        card.innerHTML = `<button class="delete-btn" title="Remove image">√ó</button>`;
        card.prepend(spinner);
        card.prepend(img);
        return card;
      },

      // Resize masonry items for proper CSS Grid masonry layout
      resizeMasonryItem(card) {
        const grid = this.el.moodboardCanvas;
        // const rowHeight = 1; // 1px
        const rowGap = 0; // we set row-gap to 0 in CSS

        // We want a visual gap bottom, which is defined by the card's margin-bottom
        // Let's assume the gap is same as column-gap (var(--space-4) usually 16px)
        const gapStyles = getComputedStyle(grid).columnGap || '16px';
        const gap = parseInt(gapStyles) || 16;

        // Ensure the card has the margin set
        card.style.marginBottom = `${gap}px`;

        const contentHeight = card.getBoundingClientRect().height;
        // Total height needed = content + gap
        // Since row height is 1px and row-gap is 0, span is just total pixel height
        const rowSpan = Math.ceil(contentHeight + gap);

        card.style.gridRowEnd = `span ${rowSpan}`;
      },

      resizeAllMasonryItems() {
        // Include the add-card-btn in the resizing logic
        const allItems = this.el.moodboardCanvas.querySelectorAll('.moodboard-card, .add-card-btn');
        allItems.forEach(item => this.resizeMasonryItem(item));
      },

      openModal(modalId) { this.el[modalId].classList.add('show'); },
      closeModal(modalId) { this.el[modalId].classList.remove('show'); },

      openColorPickerModal(index) {
        this.currentColorIndex = index;
        const color = this.state.colors[index];
        this.el.colorPickerNative.value = color;
        this.el.colorPickerHex.value = color;
        this.openModal('colorPickerModal');
      },

      saveColorFromModal() {
        const newColor = this.el.colorPickerHex.value.toUpperCase();
        if (this.currentColorIndex !== null) {
          this.state.colors[this.currentColorIndex] = newColor;
          this.saveAndRender();
        }
        this.closeModal('colorPickerModal');
      },

      syncColorInputs(source) {
        const hexRegex = /^#([0-9A-F]{3}){1,2}$/i;
        if (source === 'native') {
          this.el.colorPickerHex.value = this.el.colorPickerNative.value.toUpperCase();
        } else if (hexRegex.test(this.el.colorPickerHex.value)) {
          this.el.colorPickerNative.value = this.el.colorPickerHex.value;
        }
      },

      handleFileUploads(files, isLogo = false) {
        if (!files || files.length === 0) return;

        if (isLogo) {
          const file = files[0];
          const reader = new FileReader();
          reader.onload = (e) => {
            this.state.logo = e.target.result;
            this.saveAndRender();
          };
          reader.readAsDataURL(file);
        } else {
          const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
          let loadedCount = 0;
          const totalFiles = imageFiles.length;

          imageFiles.forEach(file => {
            const reader = new FileReader();
            reader.onload = (e) => {
              const newImage = {
                id: Date.now() + Math.random(),
                src: e.target.result // data URL instead of blob URL
              };
              this.state.images.push(newImage);
              loadedCount++;
              this.render();
              // Regenerate palette after all images are loaded
              if (loadedCount === totalFiles) {
                setTimeout(() => this.regeneratePalette(), 100);
              }
            };
            reader.readAsDataURL(file);
          });
        }
      },

      addImage() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.multiple = true;
        input.onchange = (e) => this.handleFileUploads(e.target.files);
        input.click();
      },

      removeImage(id) {
        const idToRemove = parseFloat(id);
        this.state.images = this.state.images.filter(img => img.id !== idToRemove);
        this.render();
        this.regeneratePalette();
      },

      handleDragOver(e) { e.preventDefault(); this.el.mainPanel.classList.add('drag-over'); },
      handleDragLeave(e) { this.el.mainPanel.classList.remove('drag-over'); },
      handleFileDrop(e) {
        e.preventDefault();
        this.el.mainPanel.classList.remove('drag-over');
        this.handleFileUploads(e.dataTransfer.files);
      },

      handleItemDragStart(e) {
        this.draggedItemId = e.target.dataset.id;
        e.target.classList.add('dragging');
      },
      handleItemDragEnd(e) {
        e.target.classList.remove('dragging');
        this.draggedItemId = null;
      },
      handleItemDragOver(e) { e.preventDefault(); },
      handleItemDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        const targetCard = e.target.closest('.moodboard-card');
        if (!targetCard || targetCard.dataset.id === this.draggedItemId) return;

        const draggedIndex = this.state.images.findIndex(img => img.id == this.draggedItemId);
        const targetIndex = this.state.images.findIndex(img => img.id == targetCard.dataset.id);

        const [draggedItem] = this.state.images.splice(draggedIndex, 1);
        this.state.images.splice(targetIndex, 0, draggedItem);
        this.render();
      },

      async regeneratePalette() {
        if (this.state.images.length === 0) {
          this.state.colors = [];
          this.saveAndRender();
          return;
        }

        // Extract colors from images already loaded in the DOM
        const canvas = this.el.moodboardCanvas;
        const imgElements = canvas.querySelectorAll('.moodboard-card img.loaded');

        if (imgElements.length === 0) {
          // Wait for images to load
          setTimeout(() => this.regeneratePalette(), 200);
          return;
        }

        const colorPromises = Array.from(imgElements).map(img => this.extractColorsFromElement(img));
        const colorSets = await Promise.all(colorPromises);

        const colorCounts = new Map();
        colorSets.flat().forEach(color => {
          colorCounts.set(color, (colorCounts.get(color) || 0) + 1);
        });

        const sortedColors = Array.from(colorCounts.entries())
          .sort((a, b) => b[1] - a[1])
          .map(entry => entry[0]);

        this.state.colors = sortedColors.slice(0, 6);
        this.saveAndRender();
      },

      // Extract colors directly from an img element already in the DOM
      extractColorsFromElement(imgElement) {
        return new Promise((resolve) => {
          try {
            const canvas = document.createElement('canvas');
            const MAX_WIDTH = 100;
            const scale = MAX_WIDTH / imgElement.naturalWidth;
            canvas.width = MAX_WIDTH;
            canvas.height = Math.max(1, Math.floor(imgElement.naturalHeight * scale));
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(imgElement, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            const colorCounts = {};
            let nonTransparentPixels = 0;

            for (let i = 0; i < imageData.length; i += 4) {
              const r = imageData[i];
              const g = imageData[i + 1];
              const b = imageData[i + 2];
              const a = imageData[i + 3];

              // Skip transparent pixels
              if (a < 125) continue;
              nonTransparentPixels++;

              // Skip very dark or very light pixels (increased thresholds)
              const l = 0.2126 * r + 0.7152 * g + 0.0722 * b;
              if (l > 230 || l < 30) continue;

              // Skip grayscale/low saturation pixels
              const maxC = Math.max(r, g, b);
              const minC = Math.min(r, g, b); // CORRECTED from min to minC in logic
              const saturation = maxC === 0 ? 0 : (maxC - minC) / maxC;
              if (saturation < 0.15) continue;

              // Quantize colors (group by 32 for better variation)
              const qr = Math.round(r / 32) * 32;
              const qg = Math.round(g / 32) * 32;
              const qb = Math.round(b / 32) * 32;

              // Skip if quantized result is too dark (near black)
              if (qr + qg + qb < 64) continue;

              const key = `${qr},${qg},${qb}`;
              colorCounts[key] = (colorCounts[key] || 0) + 1;
            }

            // If we found mostly transparent or filtered pixels, try again with relaxed constraints?
            // For now, if we found NOTHING, let's at least grab the center pixel color as fallback
            if (Object.keys(colorCounts).length === 0 && nonTransparentPixels > 0) {
              // Fallback: Sample center pixel
              const centerIdx = Math.floor(imageData.length / 2) - (Math.floor(imageData.length / 2) % 4);
              const fr = imageData[centerIdx];
              const fg = imageData[centerIdx + 1];
              const fb = imageData[centerIdx + 2];
              const fkey = `${fr},${fg},${fb}`;
              colorCounts[fkey] = 1;
            }

            const sortedColors = Object.keys(colorCounts)
              .sort((a, b) => colorCounts[b] - colorCounts[a]);

            const topColors = sortedColors.slice(0, 10).map(key => {
              const [r, g, b] = key.split(',').map(Number);
              // Ensure minimum brightness for hex conversion ensures we never return pure black #000000
              const mr = Math.max(r, 16);
              const mg = Math.max(g, 16);
              const mb = Math.max(b, 16);
              return `#${mr.toString(16).padStart(2, '0')}${mg.toString(16).padStart(2, '0')}${mb.toString(16).padStart(2, '0')}`;
            });

            resolve(topColors);
          } catch (e) {
            console.warn('Could not extract colors from image element:', e);
            resolve([]);
          }
        });
      },

      async exportToImage(button) {
        button.textContent = 'Generating...'; button.disabled = true;
        const exportContainer = document.createElement('div');
        const themeStyles = getComputedStyle(document.documentElement);

        const logoHtml = this.state.logo ? `<img src="${this.state.logo}" style="height: 40px; max-width: 120px; object-fit: contain; margin-left: 24px;">` : '';
        const colorsHtml = this.state.colors.map(c => `<div style="width: 32px; height: 32px; border-radius: 50%; background-color: ${c};"></div>`).join('');
        const imagesHtml = this.state.images.map(img => `<img src="${img.src}" style="width: 100%; display: block; break-inside: avoid; margin-bottom: 16px; border-radius: 8px;">`).join('');
        exportContainer.style.cssText = `position: absolute; left: -9999px; width: 1200px; padding: 40px; background-color: ${themeStyles.getPropertyValue('--surface-alt').trim()}; color: ${themeStyles.getPropertyValue('--ink').trim()}; font-family: ${themeStyles.getPropertyValue('--font-family-sans').trim()};`;
        exportContainer.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid ${themeStyles.getPropertyValue('--border-color').trim()}; padding-bottom: 24px; margin-bottom: 24px;"><h1 style="font-size: 32px; font-weight: 600; margin: 0;">${this.state.title}</h1><div style="display: flex; gap: 12px; align-items: center;">${colorsHtml}${logoHtml}</div></div><div style="column-count: 4; column-gap: 16px;">${imagesHtml}</div>`;
        document.body.appendChild(exportContainer);
        try {
          const canvas = await html2canvas(exportContainer, { scale: 2, useCORS: true, allowTaint: true });
          const link = document.createElement('a');
          link.href = canvas.toDataURL('image/png');
          link.download = `${this.state.title.replace(/\s+/g, '-')}-moodboard.png`;
          link.click();
        } catch (error) {
          console.error("Error exporting to image:", error);
          alert("An error occurred while generating the image.");
        } finally {
          document.body.removeChild(exportContainer);
          button.textContent = 'Download'; button.disabled = false;
        }
      },

      initTheme() {
        const savedTheme = localStorage.getItem('creative-toolkit-theme') || 'system';
        this.setTheme(savedTheme, false);
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
          if (localStorage.getItem('creative-toolkit-theme') === 'system') this.applyTheme('system');
        });
      },

      setTheme(theme, save = true) {
        if (save) localStorage.setItem('creative-toolkit-theme', theme);
        this.el.themeToggle.textContent = this.THEME_ICONS[theme];
        this.applyTheme(theme);
      },

      cycleTheme() {
        const currentTheme = localStorage.getItem('creative-toolkit-theme') || 'system';
        this.setTheme(this.THEMES[(this.THEMES.indexOf(currentTheme) + 1) % this.THEMES.length]);
      },

      applyTheme(theme) {
        const isDark = (theme === 'system') ? window.matchMedia('(prefers-color-scheme: dark)').matches : theme === 'dark';
        document.documentElement.dataset.theme = isDark ? 'dark' : 'light';
      },

      openWiki() {
        if (!this.el.wikiOverlay.querySelector('.wiki-modal-content')) {
          const wikiModal = document.createElement('div');
          wikiModal.className = 'wiki-modal-content';
          wikiModal.innerHTML = `
                  <div class="wiki-header">
                    <h3 id="wiki-title">Info</h3>
                    <button id="wiki-close-btn" title="Close">√ó</button>
                  </div>
                  <div id="wiki-content"></div>`;
          this.el.wikiOverlay.appendChild(wikiModal);
          wikiModal.querySelector('#wiki-close-btn').addEventListener('click', () => this.closeWiki());
        }

        if (!this.state.isWikiLoaded) {
          const titleEl = this.el.wikiOverlay.querySelector('#wiki-title');
          const contentEl = this.el.wikiOverlay.querySelector('#wiki-content');
          titleEl.textContent = WIKI_DATA.title;

          const col1 = document.createElement('div'); col1.className = 'wiki-column';
          const col2 = document.createElement('div'); col2.className = 'wiki-column';

          WIKI_DATA.sections.forEach((s, index) => {
            const sectionContainer = document.createElement('div');
            const h4 = document.createElement('h4'); h4.textContent = s.title;
            sectionContainer.appendChild(h4);
            s.content.forEach(c => { const p = document.createElement('p'); p.innerHTML = c; sectionContainer.appendChild(p); });
            if (index < WIKI_DATA.sections.length / 2) {
              col1.appendChild(sectionContainer);
            } else {
              col2.appendChild(sectionContainer);
            }
          });

          contentEl.innerHTML = '';
          contentEl.appendChild(col1);
          contentEl.appendChild(col2);

          this.state.isWikiLoaded = true;
        }
        this.el.wikiOverlay.classList.add('show');
      },
      closeWiki() { this.el.wikiOverlay.classList.remove('show'); },
    };

    document.addEventListener('DOMContentLoaded', () => App.init());
  </script>
  <a id="visitor-badge" class="visitor-badge" href="#" target="_blank" title="Visitors"></a>
  <script src="../shared/visitor-badge.js"></script>
</body>

</html>