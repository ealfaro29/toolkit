<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Blob Studio â€” SVG Organic Shape Generator</title>

  <link rel="stylesheet" href="../shared/styles.css" />
  <style>
    /* === BLOB-SPECIFIC STYLES === */

    /* Header spans full width in grid */
    header.panel {
      grid-column: 1 / -1;
    }

    /* Grid background for blob canvas */
    main.panel {
      display: grid;
      padding: 0;
      overflow: hidden;
      background-size: 40px 40px;
      background-image: linear-gradient(to right, var(--border-color) 1px, transparent 1px),
        linear-gradient(to bottom, var(--border-color) 1px, transparent 1px);
    }

    /* Background image for wiki header */
    .wiki-header {
      background-image: url('modal.png');
    }

    /* Blob SVG styles */
    .stage {
      width: 100%;
      height: 100%;
    }

    svg {
      display: block;
      width: 100%;
      height: 100%;
    }

    #blob {
      fill: var(--accent-color);
      transition: fill var(--duration-standard) ease;
    }
  </style>
</head>

<body>
  <div class="splash-overlay" id="splash-screen">
    <div class="splash-content">
      <button id="splash-close-btn" title="Close">&times;</button>
      <div class="splash-info">
        <span class="splash-icon">ðŸ’§</span>
        <h2 class="splash-title">Blob Studio</h2>
        <p class="splash-tech">Generates unique, organic shapes using procedural SVG path creation directly in your
          browser.</p>
        <p class="splash-credits">2025. Toolkit by e</p>
        <label class="splash-dont-show">
          <input type="checkbox" id="splash-dont-show-checkbox">
          Dont show again
        </label>
      </div>
      <div class="splash-image">
        <img src="modal.png" alt="Blob Studio Splash Image">
      </div>
    </div>
  </div>

  <div class="container loading" id="app-container">
    <header class="panel">
      <a href="../index.html" class="back-to-home" title="Return to Home">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5"
          stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
        </svg>
      </a>
      <h1>Blob Studio</h1>
      <div class="sub">Smooth, exportable SVG blobs.</div>
      <div class="theme-switcher">
        <button id="wiki-open-btn" title="Info">â“˜</button>
        <button id="theme-toggle" title="Change theme"></button>
      </div>
    </header>
    <aside class="panel controls" id="controls">
      <div class="control-group">
        <button class="btn btn-secondary" id="randomize">Generate</button>
      </div>
      <div class="control-group">
        <div class="slider-row">
          <label for="points">Points</label>
          <input id="points" type="range" min="3" max="9" value="5" step="1">
          <input class="num-input" id="points_num" type="number" min="3" max="9" step="1" value="5">
        </div>
        <div class="slider-row">
          <label for="smooth">Smoothness</label>
          <input id="smooth" type="range" min="0.8" max="1.5" value="1.05" step="0.05">
          <input class="num-input" id="smooth_num" type="number" min="0.8" max="1.5" step="0.05" value="1.05">
        </div>
        <div class="slider-row">
          <label for="variance">Variance</label>
          <input id="variance" type="range" min="0.1" max="0.5" value="0.39" step="0.01">
          <input class="num-input" id="variance_num" type="number" min="0.1" max="0.5" step="0.01" value="0.39">
        </div>
      </div>
      <div class="control-group">
        <button class="btn btn-primary download-svg">Download</button>
      </div>
      <div class="note">Tip: Share the URL to share your blob shape, otherwise you will lose it forever!</div>
    </aside>
    <main class="panel" id="canvas-container">
      <div class="stage">
        <svg id="svg" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Blob preview">
          <path id="blob" d="" />
        </svg>
      </div>
    </main>
  </div>

  <div id="toast" class="toast"></div>
  <div class="visually-hidden" aria-live="polite" id="aria-notifications"></div>

  <div id="wiki-overlay" class="popup-overlay"></div>

  <script type="module">
    // --- UTILITY FUNCTIONS ---
    function mulberry32(a) { return function () { let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
    function randInt(min, max) { return Math.floor(min + Math.random() * (max - min + 1)); }
    function randFloat(min, max) { return min + Math.random() * (max - min); }

    function closedCRtoBezier(points, tension) {
      const n = points.length; if (n < 2) return '';
      let d = `M ${points[0].x.toFixed(2)} ${points[0].y.toFixed(2)}`;
      for (let i = 0; i < n; i++) {
        const p0 = points[(i - 1 + n) % n], p1 = points[i], p2 = points[(i + 1) % n], p3 = points[(i + 2) % n];
        const c1x = p1.x + (p2.x - p0.x) * (tension / 6), c1y = p1.y + (p2.y - p0.y) * (tension / 6);
        const c2x = p2.x - (p3.x - p1.x) * (tension / 6), c2y = p2.y - (p3.y - p1.y) * (tension / 6);
        d += ` C ${c1x.toFixed(2)} ${c1y.toFixed(2)} ${c2x.toFixed(2)} ${c2y.toFixed(2)} ${p2.x.toFixed(2)} ${p2.y.toFixed(2)}`;
      }
      return d + ' Z';
    }

    function generatePoints({ seed, points, radius, variance, center }) {
      const rand = mulberry32(seed); const pts = [];
      for (let i = 0; i < points; i++) {
        const a = i * (Math.PI * 2 / points);
        const r = radius * (1 + (rand() * 2 - 1) * variance);
        pts.push({ x: center.x + Math.cos(a) * r, y: center.y + Math.sin(a) * r });
      }
      return pts;
    }

    const adjectives = ['blobby', 'gooey', 'squishy', 'wobbly', 'fluffy', 'round', 'organic', 'smooth', 'lumpy', 'bumpy'];
    const nouns = ['blob', 'glob', 'glorp', 'gloop', 'shape', 'form', 'mass', 'spot', 'splat'];

    const WIKI_DATA = {
      "title": "Blob Studio Info",
      "sections": [
        {
          "title": "How to Use",
          "content": [
            "<b>1. Generate Blobs:</b> Click the 'Generate' button to create a new random blob shape.",
            "<b>2. Adjust Parameters:</b> Use the sliders or input fields for 'Points', 'Smoothness', and 'Variance' to fine-tune your blob's appearance:",
            "  - <b>Points:</b> Controls the number of anchor points that define the blob's shape (3-9). More points generally lead to more complex shapes.",
            "  - <b>Smoothness:</b> Determines how smoothly the curves connect between points. Higher values create rounder, more organic shapes.",
            "  - <b>Variance:</b> Controls the randomness of each point's distance from the center. Higher variance results in more irregular, 'spiky' blobs.",
            "<b>3. Download:</b> Click the 'Download' button to save your current blob as an SVG file."
          ]
        },
        {
          "title": "What is an SVG Blob?",
          "content": [
            "An SVG (Scalable Vector Graphics) blob is a graphic element that represents an organic, often irregular, shape. Unlike raster images (like JPEGs or PNGs) that are made of pixels, SVGs are defined by mathematical paths. This means they can be scaled to any size without losing quality or becoming pixelated.",
            "Blobs are popular in modern web design and UI/UX for adding a playful, fluid, and distinctive aesthetic. They can be used as background elements, decorative accents, or even masks for images."
          ]
        }
      ]
    };

    const BlobApp = {
      state: { seed: 380098792, points: 5, variance: 0.39, smooth: 1.05, splashHidden: false },
      el: {}, THEMES: ['light', 'dark', 'system'], THEME_ICONS: { light: 'â˜€ï¸', dark: 'ðŸŒ”', system: 'âš™ï¸' },
      FIXED_FILL: '#8c19d8', canvasSize: { width: 0, height: 0 }, isWikiLoaded: false,

      init() {
        this.cacheDOMElements();
        this.initTheme();
        this.checkSplashPreference();
        this.initResizeObserver();
        this.loadStateFromURL();
        this.syncUIToState();
        this.bindEvents();
        this.render();
      },

      hideSplashScreen(dontShowAgain = false) {
        if (!this.state.splashHidden) {
          this.state.splashHidden = true;
          this.el.splashScreen.classList.add('hidden');
          this.el.appContainer.classList.remove('loading');
          if (dontShowAgain) {
            localStorage.setItem('blobs-splash-hidden', 'true');
          }
        }
      },

      checkSplashPreference() {
        if (localStorage.getItem('blobs-splash-hidden') === 'true') {
          this.state.splashHidden = true;
          this.el.splashScreen.classList.add('hidden');
          this.el.appContainer.classList.remove('loading');
        }
      },

      cacheDOMElements() {
        const ids = [
          'randomize', 'points', 'points_num', 'variance', 'variance_num', 'smooth', 'smooth_num',
          'svg', 'blob', 'toast', 'aria-notifications', 'theme-toggle', 'canvas-container', 'controls',
          'wiki-open-btn', 'wiki-overlay', 'splash-screen', 'app-container', 'splash-close-btn'
        ];
        ids.forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            const camelCaseKey = id.replace(/[-_](\w)/g, (_, char) => char.toUpperCase());
            this.el[camelCaseKey] = element;
          }
        });
        if (this.el.controls) {
          this.el.downloadSvgBtns = this.el.controls.querySelectorAll('.download-svg');
        }
      },

      initResizeObserver() {
        const observer = new ResizeObserver(entries => {
          for (const entry of entries) {
            const { width, height } = entry.contentRect;
            this.canvasSize = { width, height };
            if (this.el.svg) this.el.svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
            this.render();
          }
        });
        if (this.el.canvasContainer) observer.observe(this.el.canvasContainer);
      },

      bindEvents() {
        if (this.el.controls) {
          this.el.controls.addEventListener('input', e => {
            if (!e.target || !e.target.id || e.target.type === 'button') return;

            const { id, value } = e.target;
            const stateKey = id.replace('_num', '');

            if (this.state.hasOwnProperty(stateKey)) {
              this.state[stateKey] = +value;

              const elRange = document.getElementById(stateKey);
              const elNum = document.getElementById(`${stateKey}_num`);
              if (elRange) elRange.value = value;
              if (elNum) elNum.value = value;

              this.render();
              this.updateURL();
            }
          });
        }

        if (this.el.randomize) this.el.randomize.addEventListener('click', () => this.randomizeShape());
        if (this.el.themeToggle) this.el.themeToggle.addEventListener('click', () => this.cycleTheme());
        document.querySelectorAll('.download-svg').forEach(btn => btn.addEventListener('click', () => this.downloadSvg()));
        if (this.el.wikiOpenBtn) this.el.wikiOpenBtn.addEventListener('click', (e) => { e.preventDefault(); this.openWiki(); });
        if (this.el.splashScreen) this.el.splashScreen.addEventListener('click', (e) => {
          if (e.target === this.el.splashScreen) {
            this.hideSplashScreen();
          }
        });
        if (this.el.splashCloseBtn) this.el.splashCloseBtn.addEventListener('click', () => { const cb = document.getElementById('splash-dont-show-checkbox'); this.hideSplashScreen(cb?.checked || false); });
      },

      initTheme() {
        const savedTheme = localStorage.getItem('creative-toolkit-theme') || 'system';
        this.setTheme(savedTheme, false);
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
          if (localStorage.getItem('creative-toolkit-theme') === 'system') this.applyTheme('system');
        });
      },
      setTheme(theme, save = true) {
        if (save) localStorage.setItem('creative-toolkit-theme', theme);
        if (this.el.themeToggle) this.el.themeToggle.textContent = this.THEME_ICONS[theme];
        this.applyTheme(theme);
      },
      cycleTheme() {
        const currentTheme = localStorage.getItem('creative-toolkit-theme') || 'system';
        const currentIndex = this.THEMES.indexOf(currentTheme);
        const nextTheme = this.THEMES[(currentIndex + 1) % this.THEMES.length];
        this.setTheme(nextTheme);
      },
      applyTheme(theme) {
        const isDark = (theme === 'system') ? window.matchMedia('(prefers-color-scheme: dark)').matches : theme === 'dark';
        document.documentElement.dataset.theme = isDark ? 'dark' : 'light';
      },

      render() {
        if (!this.el.blob || !this.el.svg) return;
        const oldPath = this.el.blob.getAttribute('d');
        const radius = Math.min(this.canvasSize.width, this.canvasSize.height) * 0.25;
        const center = { x: this.canvasSize.width / 2, y: this.canvasSize.height / 2 };
        const points = generatePoints({ ...this.state, radius, center });
        const newPath = closedCRtoBezier(points, this.state.smooth);
        if (!oldPath || oldPath === newPath) { this.el.blob.setAttribute('d', newPath); return; }
        Array.from(this.el.blob.children).forEach(child => child.tagName === 'animate' && child.remove());
        const animateEl = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
        animateEl.setAttribute('attributeName', 'd');
        animateEl.setAttribute('from', oldPath);
        animateEl.setAttribute('to', newPath);
        animateEl.setAttribute('dur', '0.5s');
        animateEl.setAttribute('fill', 'freeze');
        animateEl.setAttribute('calcMode', 'spline');
        animateEl.setAttribute('keyTimes', '0; 1');
        animateEl.setAttribute('keySplines', '0.16 1 0.3 1');
        animateEl.addEventListener('endEvent', () => { this.el.blob.setAttribute('d', newPath); animateEl.remove(); });
        this.el.blob.appendChild(animateEl);
        animateEl.beginElement();
      },

      loadStateFromURL() {
        if (!window.location.hash) return;
        try {
          const params = new URLSearchParams(window.location.hash.substring(1));
          for (const [key, value] of params) {
            if (this.state.hasOwnProperty(key)) this.state[key] = isNaN(Number(value)) ? value : Number(value);
          }
        } catch (error) { console.error("Failed to parse state from URL hash.", error); }
      },
      updateURL() {
        const { splashHidden, ...stateToSave } = this.state;
        const params = new URLSearchParams(stateToSave);
        window.location.hash = params.toString();
      },

      syncUIToState() {
        for (const key in this.state) {
          if (this.state.hasOwnProperty(key)) {
            const value = this.state[key];
            const elRange = document.getElementById(key);
            const elNum = document.getElementById(`${key}_num`);
            if (elRange) elRange.value = value;
            if (elNum) elNum.value = value;
          }
        }
      },

      randomizeShape() {
        this.state.seed = randInt(1, 2 ** 31);
        this.state.points = randInt(3, 9);
        this.state.variance = randFloat(0.1, 0.5);
        this.state.smooth = randFloat(0.8, 1.5);
        this.syncUIToState();
        this.render();
        this.updateURL();
      },

      showToast(message) {
        if (this.el.toast) {
          this.el.toast.textContent = message; this.el.toast.classList.add('show');
          this.updateAriaLive(message);
          setTimeout(() => this.el.toast.classList.remove('show'), 2000);
        }
      },
      updateAriaLive(message) { if (this.el.ariaNotifications) this.el.ariaNotifications.textContent = message; },

      currentSvgText() {
        if (!this.el.blob) return '';
        const currentPath = this.el.blob.getAttribute('d'); if (!currentPath) return '';
        const tempSvgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        const tempPathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        tempPathElement.setAttribute('d', currentPath); tempSvgContainer.appendChild(tempPathElement);
        tempSvgContainer.style.position = 'absolute'; tempSvgContainer.style.visibility = 'hidden';
        document.body.appendChild(tempSvgContainer);
        const tempBBox = tempPathElement.getBBox(); document.body.removeChild(tempSvgContainer);
        const padding = 2; const x = tempBBox.x - padding; const y = tempBBox.y - padding;
        const w = Math.round(tempBBox.width) + (padding * 2); const h = Math.round(tempBBox.height) + (padding * 2);
        const finalPathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        finalPathElement.setAttribute('d', currentPath);
        finalPathElement.setAttribute('transform', `translate(${-x}, ${-y})`);
        finalPathElement.setAttribute('fill', getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim());
        const pathString = finalPathElement.outerHTML;
        const viewBox = `0 0 ${w} ${h}`;
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}" width="${w}" height="${h}">${pathString}</svg>`;
        return `<?xml version="1.0" standalone="no"?>\n${svg}`;
      },

      downloadSvg() {
        const rand = mulberry32(this.state.seed);
        const filename = `${adjectives[Math.floor(rand() * adjectives.length)]}-${nouns[Math.floor(rand() * nouns.length)]}.svg`;
        const blob = new Blob([this.currentSvgText()], { type: 'image/svg+xml' });
        this.triggerDownload(URL.createObjectURL(blob), filename);
      },
      triggerDownload(url, filename) {
        const a = document.createElement('a'); a.href = url; a.download = filename;
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 0);
      },

      openWiki() {
        if (!this.el.wikiOverlay.querySelector('.wiki-modal-content')) {
          const wikiModal = document.createElement('div');
          wikiModal.className = 'wiki-modal-content';
          wikiModal.setAttribute('role', 'dialog');
          wikiModal.innerHTML = `
                  <div class="wiki-header">
                    <h3 id="wiki-title">Info</h3>
                    <button id="wiki-close-btn" title="Close">Ã—</button>
                  </div>
                  <div id="wiki-content"></div>
              `;
          this.el.wikiOverlay.appendChild(wikiModal);
          document.getElementById('wiki-close-btn').addEventListener('click', () => this.closeWiki());
        }

        if (!this.isWikiLoaded) {
          const titleEl = document.getElementById('wiki-title');
          const contentEl = document.getElementById('wiki-content');
          titleEl.textContent = WIKI_DATA.title;

          const col1 = document.createElement('div');
          col1.className = 'wiki-column';
          const col2 = document.createElement('div');
          col2.className = 'wiki-column';

          WIKI_DATA.sections.forEach((s, index) => {
            const sectionContainer = document.createElement('div');
            const h4 = document.createElement('h4');
            h4.textContent = s.title;
            sectionContainer.appendChild(h4);
            s.content.forEach(c => {
              const p = document.createElement('p');
              p.innerHTML = c;
              sectionContainer.appendChild(p);
            });
            if (index < 1) { // How to Use
              col1.appendChild(sectionContainer);
            } else { // What is an SVG Blob?
              col2.appendChild(sectionContainer);
            }
          });

          contentEl.innerHTML = '';
          contentEl.appendChild(col1);
          contentEl.appendChild(col2);

          this.isWikiLoaded = true;
        }
        this.el.wikiOverlay.classList.add('show');
      },
      closeWiki() { if (this.el.wikiOverlay) this.el.wikiOverlay.classList.remove('show'); },
    };

    document.addEventListener('DOMContentLoaded', () => BlobApp.init());
  </script>
</body>

</html>