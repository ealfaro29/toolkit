<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Background Remover ‚Äî Client-side</title>
  <script>
    // This script is placed in the <head> to prevent a theme flash on load.
    (function () {
      try {
        let theme = localStorage.getItem('creative-toolkit-theme') || 'system';
        if (theme === 'system') {
          theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }
        document.documentElement.dataset.theme = theme;
      } catch (e) { /* Gracefully handle potential errors */ }
    })();
  </script>
  <link rel="stylesheet" href="../shared/styles.css" />
  <style>
    /* === BGREMOVER-SPECIFIC STYLES === */

    /* Single column layout (no sidebar) */
    .container {
      grid-template-columns: 1fr;
    }

    /* Workspace with grid pattern background */
    main.panel.workspace {
      padding: 0;
      display: grid;
      place-items: stretch;
      min-height: 0;
      overflow: hidden;
    }

    .workcard {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: inherit;
      overflow: hidden;
      background:
        linear-gradient(to right, color-mix(in oklab, var(--ink) 12%, transparent) 1px, transparent 1px) 0 0 / 24px 24px,
        linear-gradient(to bottom, color-mix(in oklab, var(--ink) 12%, transparent) 1px, transparent 1px) 0 0 / 24px 24px,
        var(--surface-alt);
    }

    #zone {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #zone.drag {
      outline: 3px solid color-mix(in oklab, var(--accent-color) 60%, black 0%);
      outline-offset: -3px;
    }

    canvas#view {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: transparent
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none
    }

    .status {
      padding: 8px 16px;
      border-radius: 10px;
      border: 1px solid var(--border-color);
      background: color-mix(in oklab, var(--surface-alt) 92%, black 8%);
      font-size: .9rem;
      display: none;
      gap: 12px;
      align-items: center;
      font-weight: 500;
    }

    .spinner {
      animation: rotate 2s linear infinite;
      width: 20px;
      height: 20px;
    }

    .spinner .path {
      stroke: var(--accent-color);
      stroke-linecap: round;
      animation: dash 1.5s ease-in-out infinite;
    }

    @keyframes rotate {
      100% {
        transform: rotate(360deg);
      }
    }

    @keyframes dash {
      0% {
        stroke-dasharray: 1, 150;
        stroke-dashoffset: 0;
      }

      50% {
        stroke-dasharray: 90, 150;
        stroke-dashoffset: -35;
      }

      100% {
        stroke-dasharray: 90, 150;
        stroke-dashoffset: -124;
      }
    }

    .bar {
      display: none
    }

    input[type=file] {
      display: none
    }

    /* Wiki header background */
    .wiki-header {
      background-image: url('modal.png');
    }

    /* Mobile responsive overrides */
    @media(max-width:800px) {
      main.panel.workspace {
        min-height: 50vh
      }
    }
  </style>
</head>

<body>
  <div class="splash-overlay" id="splash-screen">
    <div class="splash-content">
      <button id="splash-close-btn" title="Close">&times;</button>
      <div class="splash-info">
        <span class="splash-icon">‚úÇÔ∏è</span>
        <h2 class="splash-title">Background Remover</h2>
        <p class="splash-tech">Utilizes a local machine learning model to process images directly in your browser for
          maximum speed and full privacy. Risk free. First load can take a minute.</p>
        <p class="splash-credits">2025. Toolkit by e</p>
        <label class="splash-dont-show">
          <input type="checkbox" id="splash-dont-show-checkbox">
          Don't show again
        </label>
      </div>
      <div class="splash-image">
        <img src="modal.png" alt="Background Remover Splash Image">
      </div>
    </div>
  </div>

  <div class="container loading" id="app-container">
    <header class="panel">
      <a href="../index.html" class="back-to-home" title="Return to Home">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5"
          stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5 8.25 12 15.75 4.5" />
        </svg>
      </a>
      <h1>Background Remover</h1>
      <div class="sub">Client-side AI cutout, click, drop or paste to start</div>
      <div class="theme-switcher">
        <button id="wiki-open-btn" title="Info">‚ìò</button>
        <button id="theme-toggle" title="Change theme"></button>
      </div>
    </header>

    <main class="panel workspace" id="workspace">
      <div class="workcard" id="workcard">
        <div id="zone" title="Click, drop, or paste an image">
          <canvas id="view" width="1" height="1" aria-label="Image viewer"></canvas>
          <div class="overlay">
            <div class="status" id="status">
              <svg class="spinner" viewBox="0 0 50 50">
                <circle class="path" cx="25" cy="25" r="20" fill="none" stroke-width="5"></circle>
              </svg>
              <span id="statusText">Loading model‚Ä¶</span>
            </div>
          </div>
          <input id="file" type="file" accept="image/*" />
        </div>
      </div>
    </main>
  </div>

  <div id="wiki-overlay" class="popup-overlay"></div>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.22.0/dist/ort.min.js"></script>
  <script type="module">
    const WIKI_DATA = {
      "title": "Background Remover",
      "sections": [
        {
          "title": "How it works",
          "content": ["Runs a quantized RMBG-1.4 model in your browser via ONNX Runtime Web.", "All processing is local; first load caches ~44 MB."]
        },
        {
          "title": "Usage",
          "content": ["Click the card, drop a file, or paste with Ctrl+V.", "Processing starts automatically; a transparent PNG is downloaded when ready."]
        },
        {
          "title": "Hints",
          "content": ["Subjects with clear edges give the best results.", "WebGPU is used if available, else optimized WASM (threads + SIMD)."]
        }
      ]
    };

    const App = {
      el: {},
      state: {
        splashHidden: false,
        isWikiLoaded: false,
        session: null,
        lastBitmap: null
      },
      THEMES: ['light', 'dark', 'system'],
      ICONS: { light: '‚òÄÔ∏è', dark: 'üåî', system: '‚öôÔ∏è' },

      init() {
        this.cacheDOMElements();
        this.initTheme();
        this.checkSplashPreference();
        this.bindEvents();
        this.initSession();
      },

      hideSplashScreen(dontShowAgain = false) {
        if (!this.state.splashHidden) {
          this.state.splashHidden = true;
          this.el.splashScreen.classList.add('hidden');
          this.el.appContainer.classList.remove('loading');
          if (dontShowAgain) {
            localStorage.setItem('bgremover-splash-hidden', 'true');
          }
        }
      },

      checkSplashPreference() {
        if (localStorage.getItem('bgremover-splash-hidden') === 'true') {
          this.state.splashHidden = true;
          this.el.splashScreen.classList.add('hidden');
          this.el.appContainer.classList.remove('loading');
        }
      },

      cacheDOMElements() {
        const ids = [
          'theme-toggle', 'wiki-open-btn', 'wiki-overlay',
          'workspace', 'workcard', 'zone', 'file', 'view', 'status', 'statusText',
          'splash-screen', 'app-container', 'splash-close-btn'
        ];
        ids.forEach(id => {
          const key = id.replace(/-(\w)/g, (_, c) => c.toUpperCase());
          this.el[key] = document.getElementById(id);
        });
        this.el.ctx = this.el.view.getContext('2d', { willReadFrequently: true });
      },

      bindEvents() {
        this.el.themeToggle.addEventListener('click', () => this.cycleTheme());
        this.el.wikiOpenBtn.addEventListener('click', () => this.openWiki());
        this.el.splashScreen.addEventListener('click', (e) => {
          if (e.target === this.el.splashScreen) {
            const cb = document.getElementById('splash-dont-show-checkbox');
            this.hideSplashScreen(cb?.checked || false);
          }
        });
        this.el.splashCloseBtn.addEventListener('click', () => {
          const cb = document.getElementById('splash-dont-show-checkbox');
          this.hideSplashScreen(cb?.checked || false);
        });

        this.el.zone.addEventListener('click', () => this.el.file.click());
        this.el.file.addEventListener('change', e => this.handleFiles(e.target.files));
        this.el.zone.addEventListener('dragover', e => { e.preventDefault(); this.el.zone.classList.add('drag'); });
        this.el.zone.addEventListener('dragleave', () => this.el.zone.classList.remove('drag'));
        this.el.zone.addEventListener('drop', e => { e.preventDefault(); this.el.zone.classList.remove('drag'); const dt = e.dataTransfer; if (dt.files && dt.files.length) this.handleFiles(dt.files); });
        window.addEventListener('paste', e => { const items = e.clipboardData && e.clipboardData.items; if (!items) return; for (const it of items) { if (it.type && it.type.startsWith('image/')) { const b = it.getAsFile(); if (b) this.handleFiles([b]); break; } } });

        const ro = new ResizeObserver(() => {
          this.sizeCanvasToZone();
          if (this.state.lastBitmap) this.drawIntoPaddedInnerRect(this.state.lastBitmap);
        });
        ro.observe(this.el.workspace);
      },

      initTheme() {
        const s = localStorage.getItem('creative-toolkit-theme') || 'system'; this.setTheme(s, false);
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => { if ((localStorage.getItem('creative-toolkit-theme') || 'system') === 'system') this.applyTheme('system'); });
      },
      setTheme(t, s = true) { if (s) localStorage.setItem('creative-toolkit-theme', t); this.el.themeToggle.textContent = this.ICONS[t]; this.applyTheme(t); },
      cycleTheme() { const c = localStorage.getItem('creative-toolkit-theme') || 'system'; this.setTheme(this.THEMES[(this.THEMES.indexOf(c) + 1) % this.THEMES.length]); },
      applyTheme(t) { const d = (t === 'system') ? window.matchMedia('(prefers-color-scheme: dark)').matches : (t === 'dark'); document.documentElement.dataset.theme = d ? 'dark' : 'light'; },

      openWiki() {
        if (!this.el.wikiOverlay.querySelector('.wiki-modal-content')) {
          const wikiModal = document.createElement('div');
          wikiModal.className = 'wiki-modal-content';
          wikiModal.innerHTML = `
                    <div class="wiki-header">
                        <h3 id="wiki-title">Info</h3>
                        <button id="wiki-close-btn" title="Close">√ó</button>
                    </div>
                    <div id="wiki-content"></div>`;
          this.el.wikiOverlay.appendChild(wikiModal);
          wikiModal.querySelector('#wiki-close-btn').addEventListener('click', () => this.closeWiki());
        }

        if (!this.state.isWikiLoaded) {
          const titleEl = this.el.wikiOverlay.querySelector('#wiki-title');
          const contentEl = this.el.wikiOverlay.querySelector('#wiki-content');
          titleEl.textContent = WIKI_DATA.title;

          const col1 = document.createElement('div'); col1.className = 'wiki-column';
          const col2 = document.createElement('div'); col2.className = 'wiki-column';

          WIKI_DATA.sections.forEach((s, index) => {
            const sectionContainer = document.createElement('div');
            const h4 = document.createElement('h4'); h4.textContent = s.title;
            sectionContainer.appendChild(h4);
            s.content.forEach(c => { const p = document.createElement('p'); p.innerHTML = c; sectionContainer.appendChild(p); });
            if (index < 2) { col1.appendChild(sectionContainer); }
            else { col2.appendChild(sectionContainer); }
          });

          contentEl.innerHTML = '';
          contentEl.appendChild(col1);
          contentEl.appendChild(col2);
          this.state.isWikiLoaded = true;
        }
        this.el.wikiOverlay.classList.add('show');
      },
      closeWiki() { this.el.wikiOverlay.classList.remove('show'); },

      showLoader(text) { this.el.statusText.textContent = text; this.el.status.style.display = 'inline-flex'; },
      hideLoader() { this.el.status.style.display = 'none'; },

      async initSession() {
        try {
          this.showLoader('Initializing‚Ä¶');
          ort.env.wasm.simd = true; ort.env.wasm.proxy = true; ort.env.wasm.numThreads = Math.min(4, navigator.hardwareConcurrency || 2);
          const providers = (navigator.gpu) ? ['webgpu', 'wasm'] : ['wasm'];
          this.state.session = await ort.InferenceSession.create('./model_quantized.onnx', { executionProviders: providers });
          this.showLoader('Ready');
          setTimeout(() => this.hideLoader(), 500);
        } catch (e) { console.error(e); this.showLoader('Model load failed'); }
      },

      fitSquareGeometry(w, h) {
        const s = Math.min(1024 / w, 1024 / h);
        const newW = Math.round(w * s), newH = Math.round(h * s);
        const offX = Math.floor((1024 - newW) / 2), offY = Math.floor((1024 - newH) / 2);
        return { newW, newH, offX, offY };
      },

      async toBitmap(srcLike) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const url = (typeof srcLike === 'string') ? srcLike : URL.createObjectURL(srcLike);
          img.onload = async () => { try { const bmp = await createImageBitmap(img, { colorSpaceConversion: 'default' }); if (url.startsWith('blob:')) URL.revokeObjectURL(url); resolve(bmp); } catch (e) { reject(e); } };
          img.onerror = reject; img.src = url;
        });
      },

      sizeCanvasToZone() {
        const rect = this.el.zone.getBoundingClientRect();
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const pxW = Math.max(1, Math.floor(rect.width * dpr));
        const pxH = Math.max(1, Math.floor(rect.height * dpr));
        if (this.el.view.width !== pxW || this.el.view.height !== pxH) {
          this.el.view.width = pxW; this.el.view.height = pxH;
        }
        this.el.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        this.el.ctx.clearRect(0, 0, rect.width, rect.height);
      },

      drawIntoPaddedInnerRect(src) {
        const rect = this.el.zone.getBoundingClientRect();
        const cw = rect.width, ch = rect.height;
        const iw = src.width, ih = src.height;
        const PADDING = 24;
        const innerW = Math.max(1, cw - 2 * PADDING);
        const innerH = Math.max(1, ch - 2 * PADDING);
        const scale = Math.min(innerW / iw, innerH / ih);
        const w = Math.round(iw * scale), h = Math.round(ih * scale);
        const x = PADDING + Math.round((innerW - w) / 2);
        const y = PADDING + Math.round((innerH - h) / 2);

        this.el.ctx.clearRect(0, 0, cw, ch);
        this.el.ctx.drawImage(src, 0, 0, iw, ih, x, y, w, h);
      },

      async processImageForBackgroundRemoval(bmp) {
        const geom = this.fitSquareGeometry(bmp.width, bmp.height);
        const work = new OffscreenCanvas(1024, 1024);
        const wctx = work.getContext('2d');
        wctx.clearRect(0, 0, 1024, 1024);
        wctx.fillStyle = 'black'; wctx.fillRect(0, 0, 1024, 1024);
        wctx.drawImage(bmp, 0, 0, bmp.width, bmp.height, geom.offX, geom.offY, geom.newW, geom.newH);

        const { data } = wctx.getImageData(0, 0, 1024, 1024);
        const N = 1024 * 1024;
        const chw = new Float32Array(3 * N);
        for (let i = 0; i < N; i++) { const r = data[i * 4] / 255 - .5, g = data[i * 4 + 1] / 255 - .5, b = data[i * 4 + 2] / 255 - .5; chw[i] = r; chw[i + N] = g; chw[i + 2 * N] = b; }
        const input = new ort.Tensor('float32', chw, [1, 3, 1024, 1024]);

        const outMap = (await this.state.session.run({ [this.state.session.inputNames[0]]: input }))[this.state.session.outputNames[0]].data;

        let mn = Infinity, mx = -Infinity; for (const v of outMap) { if (v < mn) mn = v; if (v > mx) mx = v; }
        const scale = (mx > mn) ? 255 / (mx - mn) : 255;

        const maskImg = new ImageData(1024, 1024);
        for (let i = 0, p = 0; i < outMap.length; i++, p += 4) {
          const a = Math.max(0, Math.min(255, Math.round((outMap[i] - mn) * scale)));
          maskImg.data[p] = 255; maskImg.data[p + 1] = 255; maskImg.data[p + 2] = 255; maskImg.data[p + 3] = a;
        }

        const maskSq = new OffscreenCanvas(1024, 1024);
        maskSq.getContext('2d').putImageData(maskImg, 0, 0);

        const ratio = bmp.width / bmp.height;
        let outW = bmp.width > bmp.height ? 1024 : Math.round(1024 * ratio);
        let outH = bmp.width > bmp.height ? Math.round(1024 / ratio) : 1024;

        const finalCanvas = new OffscreenCanvas(outW, outH);
        const fctx = finalCanvas.getContext('2d');
        fctx.drawImage(bmp, 0, 0, outW, outH);

        const alphaRescaled = new OffscreenCanvas(outW, outH);
        const actx = alphaRescaled.getContext('2d');
        actx.drawImage(maskSq, geom.offX, geom.offY, geom.newW, geom.newH, 0, 0, outW, outH);

        const mData = actx.getImageData(0, 0, outW, outH).data;
        const imgData = fctx.getImageData(0, 0, outW, outH);
        for (let i = 0; i < imgData.data.length; i += 4) imgData.data[i + 3] = mData[i + 3];
        fctx.putImageData(imgData, 0, 0);

        return finalCanvas.transferToImageBitmap();
      },

      async handleBitmap(bmp, originalName = 'pasted-image.png') {
        this.state.lastBitmap = bmp;
        this.sizeCanvasToZone();
        this.drawIntoPaddedInnerRect(bmp);

        let messageInterval = null;

        try {
          const messages = ["Isolating subject", "Analyzing pixels", "Removing background", "Finalizing details", "Polishing edges"];
          let messageIndex = 0;
          this.showLoader(messages[messageIndex]);

          messageInterval = setInterval(() => {
            messageIndex = (messageIndex + 1) % messages.length;
            this.showLoader(messages[messageIndex]);
          }, 5000);

          const finalBitmap = await this.processImageForBackgroundRemoval(bmp);

          clearInterval(messageInterval);
          this.hideLoader();
          this.drawIntoPaddedInnerRect(finalBitmap);
          this.state.lastBitmap = finalBitmap;

          const nameWithoutExt = originalName.lastIndexOf('.') > 0 ? originalName.substring(0, originalName.lastIndexOf('.')) : originalName;
          const newFilename = `${nameWithoutExt}-bg-removed.png`;

          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = finalBitmap.width; tempCanvas.height = finalBitmap.height;
          tempCanvas.getContext('2d').drawImage(finalBitmap, 0, 0);

          tempCanvas.toBlob((blob) => {
            if (!blob) return;
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = newFilename;
            a.click();
            URL.revokeObjectURL(a.href);
          }, 'image/png');
        } catch (err) {
          console.error(err);
          if (messageInterval) clearInterval(messageInterval);
          this.hideLoader();
          this.showLoader('Processing failed');
        }
      },

      handleFiles(files) {
        const f = files && files[0];
        if (!f) return;
        const originalName = f.name;
        this.toBitmap(f)
          .then(bmp => this.handleBitmap(bmp, originalName))
          .catch(err => { console.error(err); this.showLoader('Failed to load image'); });
      }
    };

    document.addEventListener('DOMContentLoaded', () => App.init());
  </script>
</body>

</html>