<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Locator</title>
    <script>
        // This script is placed in the <head> to prevent a theme flash on load.
        (function () {
            try {
                let theme = localStorage.getItem('creative-toolkit-theme') || 'system';
                if (theme === 'system') {
                    theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
                }
                document.documentElement.dataset.theme = theme;
            } catch (e) { /* Gracefully handle potential errors */ }
        })();
    </script>
    <link href='https://unpkg.com/maplibre-gl/dist/maplibre-gl.css' rel='stylesheet' />

    <link rel="stylesheet" href="../shared/styles.css" />
    <style>
        /* === LOCATOR-SPECIFIC STYLES === */

        /* Additional theme variables for maps */
        html[data-theme="light"] {
            --map-ocean: #ddeeff;
            --map-land: #f0f0f0;
            --map-border: #bbbbbb;
        }

        html[data-theme="dark"] {
            --map-ocean: #343a40;
            --map-land: #495057;
            --map-border: #6c757d;
        }

        /* Header grid positioning */
        header.panel {
            grid-column: 1 / -1;
        }

        /* Aside controls with full height */
        aside.panel.controls {
            position: sticky;
            top: 0;
            max-height: 100%;
        }

        /* Main panel no padding for map */
        main.panel {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            min-height: 0;
            overflow: hidden;
        }

        /* Textarea and select styling */
        textarea,
        select {
            background: var(--surface);
            color: var(--ink);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: var(--space-3);
            width: 100%;
            box-sizing: border-box;
            font-size: 14px;
            font-family: var(--font-family-sans);
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* Location list header */
        .location-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--space-3);
        }

        .location-list-header h3 {
            font-size: var(--font-size-body);
            font-weight: var(--font-weight-emphasis);
            margin: 0;
        }

        /* Toggle label */
        .toggle-label {
            font-size: 0.9em;
            font-weight: normal;
            color: var(--muted);
            cursor: pointer;
            user-select: none;
        }

        /* Location list container */
        #location-list-container {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        /* Location list */
        #location-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #location-list li {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        #location-list li:hover {
            background-color: var(--surface);
        }

        /* Location name */
        .location-name {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Location controls */
        .location-controls button {
            background: none;
            border: none;
            padding: 4px;
            font-size: 16px;
            cursor: pointer;
            color: var(--muted);
            line-height: 1;
            border-radius: var(--radius-sm);
            width: auto;
        }

        .location-controls button:hover {
            color: var(--ink);
            background-color: var(--surface);
        }

        /* Not found location */
        li.not-found .location-name {
            color: #dc3545;
            font-style: italic;
        }

        /* Map container */
        #map-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* MapLibre popup custom styling */
        .maplibregl-popup-content {
            background: transparent !important;
            color: var(--ink);
            padding: 0 !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            border: none !important;
            font-size: 11px;
            font-weight: 600;
            text-shadow: 0 0 3px var(--surface-alt), 0 0 6px var(--surface-alt);
        }

        .maplibregl-popup-tip {
            display: none !important;
        }

        /* Spinner animation */
        .spinner {
            display: inline-block;
            width: 1em;
            height: 1em;
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-left: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--ink);
            color: var(--surface-alt);
            padding: var(--space-3) var(--space-5);
            border-radius: var(--radius-md);
            font-weight: var(--font-weight-emphasis);
            font-size: 14px;
            box-shadow: var(--shadow-floating-3);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 300ms ease;
        }

        .toast.show {
            bottom: 30px;
            opacity: 1;
            visibility: visible;
        }

        /* Progress bar */
        .splash-progress {
            margin-top: var(--space-4);
            width: 100%;
        }

        #splash-progress-text {
            font-size: var(--font-size-caption);
            color: var(--muted);
            margin-bottom: var(--space-2);
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: var(--surface);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar-inner {
            width: 0%;
            height: 100%;
            background-color: var(--accent-color);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        /* Wiki header background */
        .wiki-header {
            background-image: url('modal.png');
        }
    </style>
</head>

<body>
    <div class="splash-overlay" id="splash-screen">
        <div class="splash-content">
            <button id="splash-close-btn" title="Close" disabled>&times;</button>
            <div class="splash-info">
                <span class="splash-icon">üìç</span>
                <h2 class="splash-title">Locator</h2>
                <p class="splash-tech">Visualizes locations using MapLibre GL JS and the Nominatim geocoding API, all
                    processed in your browser.</p>
                <div class="splash-progress">
                    <span id="splash-progress-text">Initializing map...</span>
                    <div class="progress-bar">
                        <div id="progress-bar-inner" class="progress-bar-inner"></div>
                    </div>
                </div>
                <p class="splash-credits">2025. Toolkit by e</p>
                <label class="splash-dont-show">
                    <input type="checkbox" id="splash-dont-show-checkbox">
                    Dont show again
                </label>
            </div>
            <div class="splash-image">
                <img src="modal.png" alt="Locator Splash Image">
            </div>
        </div>
    </div>

    <div class="container loading" id="app-container">
        <header class="panel">
            <a href="../index.html" class="back-to-home" title="Return to Home">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                </svg>
            </a>
            <h1>Locator</h1>
            <div class="sub">Geocode locations and visualize them on a map.</div>
            <div class="theme-switcher">
                <button id="wiki-open-btn" title="Info">‚ìò</button>
                <button id="theme-toggle" title="Change theme"></button>
            </div>
        </header>

        <aside class="panel controls">
            <div class="control-group">
                <textarea id="locations" placeholder="e.g., Paris; London&#10;Separate with ';' or new line"></textarea>
                <button id="generate-btn" class="btn btn-secondary">
                    <span class="btn-text">Add to Map</span>
                    <span class="spinner" style="display: none;"></span>
                </button>
            </div>

            <div class="control-group" style="flex: 1; min-height: 0;">
                <div class="location-list-header">
                    <h3>Locations</h3>
                    <label class="toggle-label">
                        <input type="checkbox" id="fill-countries-checkbox"> Fill Countries
                    </label>
                </div>
                <div id="location-list-container">
                    <ul id="location-list"></ul>
                </div>
            </div>

            <div class="control-group">
                <button id="download-btn" class="btn btn-primary">Download</button>
            </div>

            <div class="note">Tip: Separate multiple locations with a new line or a semicolon (;).</div>
        </aside>

        <main class="panel" id="map-container">
            <div id="map"></div>
        </main>
    </div>

    <div id="ambiguity-popup-overlay" class="popup-overlay">
        <div class="popup-content" role="dialog">
            <p id="ambiguity-popup-msg"></p>
            <select id="ambiguity-popup-select"></select>
            <div class="popup-actions">
                <button id="ambiguity-popup-skip" class="btn">Skip</button>
                <button id="ambiguity-popup-ok" class="btn btn-primary">Select</button>
            </div>
        </div>
    </div>

    <div id="wiki-overlay" class="popup-overlay"></div>

    <div id="toast" class="toast"></div>

    <script src='https://unpkg.com/maplibre-gl/dist/maplibre-gl.js'></script>
    <script type="module">
        const WIKI_DATA = { "title": "Locator App Info", "sections": [{ "title": "How to Use", "content": ["<b>1. Add Locations:</b> Type or paste location names into the text area. Separate each location with a semicolon (;) or a new line.", "<b>2. Add to Map:</b> Click the 'Add to Map' button. The app will process each location one by one.", "<b>3. Resolve Ambiguity:</b> If a location name has multiple possible matches (e.g., 'Springfield'), a popup will appear. Select the correct one and click 'Select', or click 'Skip' to ignore it.", "<b>4. Manage the List:</b> Each successfully added location appears in the list. You can use the buttons to:", "  - üîç <b>Zoom To:</b> Pan and zoom the map to that location.", "  - üóëÔ∏è <b>Remove:</b> Delete the location from the map and the list.", "<b>5. Fill Countries:</b> Check the 'Fill Countries' box to highlight the countries where you have placed locations."] }, { "title": "Data Sources", "content": ["<b>Base Map:</b> Country outlines are from <a href='https://www.naturalearthdata.com/' target='_blank'>Natural Earth</a> (Public Domain).", "<b>Geocoding (Search):</b> Location search is performed using the public <a href='https://nominatim.org/' target='_blank'>Nominatim API</a>, which uses OpenStreetMap data."] }] };
        const ISO_A2_TO_A3_DATA = { "AF": "AFG", "AX": "ALA", "AL": "ALB", "DZ": "DZA", "AS": "ASM", "AD": "AND", "AO": "AGO", "AI": "AIA", "AQ": "ATA", "AG": "ATG", "AR": "ARG", "AM": "ARM", "AW": "ABW", "AU": "AUS", "AT": "AUT", "AZ": "AZE", "BS": "BHS", "BH": "BHR", "BD": "BGD", "BB": "BRB", "BY": "BLR", "BE": "BEL", "BZ": "BLZ", "BJ": "BEN", "BM": "BMU", "BT": "BTN", "BO": "BOL", "BQ": "BES", "BA": "BIH", "BW": "BWA", "BV": "BVT", "BR": "BRA", "IO": "IOT", "BN": "BRN", "BG": "BGR", "BF": "BFA", "BI": "BDI", "CV": "CPV", "KH": "KHM", "CM": "CMR", "CA": "CAN", "KY": "CYM", "CF": "CAF", "TD": "TCD", "CL": "CHL", "CN": "CHN", "CX": "CXR", "CC": "CCK", "CO": "COL", "KM": "COM", "CD": "COD", "CG": "COG", "CK": "COK", "CR": "CRI", "CI": "CIV", "HR": "HRV", "CU": "CUB", "CW": "CUW", "CY": "CYP", "CZ": "CZE", "DK": "DNK", "DJ": "DJI", "DM": "DMA", "DO": "DOM", "EC": "ECU", "EG": "EGY", "SV": "SLV", "GQ": "GNQ", "ER": "ERI", "EE": "EST", "SZ": "SWZ", "ET": "ETH", "FK": "FLK", "FO": "FRO", "FJ": "FJI", "FI": "FIN", "FR": "FRA", "GF": "GUF", "PF": "PYF", "TF": "ATF", "GA": "GAB", "GM": "GMB", "GE": "GEO", "DE": "DEU", "GH": "GHA", "GI": "GIB", "GR": "GRC", "GL": "GRL", "GD": "GRD", "GP": "GLP", "GU": "GUM", "GT": "GTM", "GG": "GGY", "GN": "GIN", "GW": "GNB", "GY": "GUY", "HT": "HTI", "HM": "HMD", "VA": "VAT", "HN": "HND", "HK": "HKG", "HU": "HUN", "IS": "ISL", "IN": "IND", "ID": "IDN", "IR": "IRN", "IQ": "IRQ", "IE": "IRL", "IM": "IMN", "IL": "ISR", "IT": "ITA", "JM": "JAM", "JP": "JPN", "JE": "JEY", "JO": "JOR", "KZ": "KAZ", "KE": "KEN", "KI": "KIR", "KP": "PRK", "KR": "KOR", "KW": "KWT", "KG": "KGZ", "LA": "LAO", "LV": "LVA", "LB": "LBN", "LS": "LSO", "LR": "LBR", "LY": "LBY", "LI": "LIE", "LT": "LTU", "LU": "LUX", "MO": "MAC", "MG": "MDG", "MW": "MWI", "MY": "MYS", "MV": "MDV", "ML": "MLI", "MT": "MLT", "MH": "MHL", "MQ": "MTQ", "MR": "MRT", "MU": "MUS", "YT": "MYT", "MX": "MEX", "FM": "FSM", "MD": "MDA", "MC": "MCO", "MN": "MNG", "ME": "MNE", "MS": "MSR", "MA": "MAR", "MZ": "MOZ", "MM": "MMR", "NA": "NAM", "NR": "NRU", "NP": "NPL", "NL": "NLD", "NC": "NCL", "NZ": "NZL", "NI": "NIC", "NE": "NER", "NG": "NGA", "NU": "NIU", "NF": "NFK", "MK": "MKD", "MP": "MNP", "NO": "NOR", "OM": "OMN", "PK": "PAK", "PW": "PLW", "PS": "PSE", "PA": "PAN", "PG": "PNG", "PY": "PRY", "PE": "PER", "PH": "PHL", "PN": "PCN", "PL": "POL", "PT": "PRT", "PR": "PRI", "QA": "QAT", "RE": "REU", "RO": "ROU", "RU": "RUS", "RW": "RWA", "BL": "BLM", "SH": "SHN", "KN": "KNA", "LC": "LCA", "MF": "MAF", "PM": "SPM", "VC": "VCT", "WS": "WSM", "SM": "SMR", "ST": "STP", "SA": "SAU", "SN": "SEN", "RS": "SRB", "SC": "SYC", "SL": "SLE", "SG": "SGP", "SX": "SXM", "SK": "SVK", "SI": "SVN", "SB": "SLB", "SO": "SOM", "ZA": "ZAF", "GS": "SGS", "SS": "SSD", "ES": "ESP", "LK": "LKA", "SD": "SDN", "SR": "SUR", "SJ": "SJM", "SE": "SWE", "CH": "CHE", "SY": "SYR", "TW": "TWN", "TJ": "TJK", "TZ": "TZA", "TH": "THA", "TL": "TLS", "TG": "TGO", "TK": "TKL", "TO": "TON", "TT": "TTO", "TN": "TUN", "TR": "TUR", "TM": "TKM", "TC": "TCA", "TV": "TUV", "UG": "UGA", "UA": "UKR", "AE": "ARE", "GB": "GBR", "UM": "UMI", "US": "USA", "UY": "URY", "UZ": "UZB", "VU": "VUT", "VE": "VEN", "VN": "VNM", "VG": "VGB", "VI": "VIR", "WF": "WLF", "EH": "ESH", "YE": "YEM", "ZM": "ZMB", "ZW": "ZWE" };

        const App = {
            el: {}, map: null, locationsData: [], geocodeQueue: [], ambiguityChoices: [], ambiguityOriginalQuery: '', locatedCountryCodes: new Set(), isWikiLoaded: false, isoLookup: ISO_A2_TO_A3_DATA, cssColors: {},
            state: { splashHidden: false },
            THEMES: ['light', 'dark', 'system'], THEME_ICONS: { light: '‚òÄÔ∏è', dark: 'üåî', system: '‚öôÔ∏è' },
            CONFIG: { API_THROTTLE_MS: 1000, GEOJSON_URL: 'https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_50m_admin_0_countries.geojson' },

            init() { this.cacheDOMElements(); this.initTheme(); this.initMap(); this.bindEvents(); },
            cacheDOMElements() {
                const ids = ['theme-toggle', 'generate-btn', 'download-btn', 'toast', 'locations', 'location-list', 'fill-countries-checkbox', 'ambiguity-popup-overlay', 'ambiguity-popup-msg', 'ambiguity-popup-select', 'ambiguity-popup-ok', 'ambiguity-popup-skip', 'wiki-open-btn', 'wiki-overlay', 'map-container', 'map', 'splash-screen', 'app-container', 'splash-close-btn', 'splash-progress-text', 'progress-bar-inner'];
                ids.forEach(id => {
                    const camelCaseKey = id.replace(/-(\w)/g, (_, char) => char.toUpperCase());
                    this.el[camelCaseKey] = document.getElementById(id);
                });
                this.el.spinner = this.el.generateBtn.querySelector('.spinner');
                this.el.btnText = this.el.generateBtn.querySelector('.btn-text');
                this.cssColors.accent = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
            },

            updateProgress(percentage, message) {
                if (this.el.progressBarInner) this.el.progressBarInner.style.width = `${percentage}%`;
                if (this.el.splashProgressText) this.el.splashProgressText.textContent = message;
            },

            hideSplashScreen(dontShowAgain = false) {
                if (!this.state.splashHidden) {
                    this.state.splashHidden = true;
                    this.el.splashScreen.classList.add('hidden');
                    this.el.appContainer.classList.remove('loading');
                    if (dontShowAgain) {
                        localStorage.setItem('locator-splash-hidden', 'true');
                    }
                }
            },

            checkSplashPreference() {
                if (localStorage.getItem('locator-splash-hidden') === 'true') {
                    this.state.splashHidden = true;
                    this.el.splashScreen.classList.add('hidden');
                    this.el.appContainer.classList.remove('loading');
                }
            },

            initMap() {
                this.updateProgress(10, "Initializing map...");
                const initialTheme = localStorage.getItem('creative-toolkit-theme') || 'system';
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                const isDark = initialTheme === 'dark' || (initialTheme === 'system' && prefersDark);
                const initialOceanColor = isDark ? '#343a40' : '#ddeeff';

                this.map = new maplibregl.Map({
                    container: 'map',
                    style: { version: 8, sources: {}, layers: [{ id: 'background', type: 'background', paint: { 'background-color': initialOceanColor } }] },
                    center: [0, 20],
                    zoom: 1.5,
                    attributionControl: false,
                    preserveDrawingBuffer: true
                });

                this.map.on('load', () => {
                    this.updateProgress(50, "Loading geographic data...");
                    const initialLandColor = isDark ? '#495057' : '#f0f0f0';
                    const initialBorderColor = isDark ? '#6c757d' : '#bbbbbb';
                    this.map.addSource('countries-source', {
                        type: 'geojson',
                        data: this.CONFIG.GEOJSON_URL
                    });
                    this.map.addLayer({ id: 'countries-fill-layer', type: 'fill', source: 'countries-source', paint: { 'fill-color': initialLandColor } });
                    this.map.addLayer({ id: 'countries-border-layer', type: 'line', source: 'countries-source', paint: { 'line-color': initialBorderColor } });

                    this.map.once('idle', () => {
                        this.updateProgress(100, "Map ready!");
                        this.el.splashCloseBtn.disabled = false;
                    });
                });
                this.map.addControl(new maplibregl.NavigationControl(), 'top-right');
            },
            bindEvents() {
                this.el.themeToggle.addEventListener('click', () => this.cycleTheme());
                this.el.generateBtn.addEventListener('click', () => this.startGeocoding());
                this.el.downloadBtn.addEventListener('click', () => this.handleDownload());
                this.el.fillCountriesCheckbox.addEventListener('change', () => this.updateCountryFills());
                this.el.locationList.addEventListener('click', (e) => this.handleLocationListClick(e));
                this.el.ambiguityPopupOk.addEventListener('click', () => this.resolveAmbiguity());
                this.el.ambiguityPopupSkip.addEventListener('click', () => this.skipAmbiguity());
                this.el.wikiOpenBtn.addEventListener('click', (e) => { e.preventDefault(); this.openWiki(); });
                this.el.splashScreen.addEventListener('click', (e) => { if (e.target === this.el.splashScreen) { const cb = document.getElementById('splash-dont-show-checkbox'); this.hideSplashScreen(cb?.checked || false); } });
                this.el.splashCloseBtn.addEventListener('click', () => { const cb = document.getElementById('splash-dont-show-checkbox'); this.hideSplashScreen(cb?.checked || false); });
            },
            handleDownload() {
                this.showToast("Generating vector SVG...");
                try {
                    const svgString = this.generateTrueSVG();
                    const blob = new Blob([svgString], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'locator-map.svg';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (err) {
                    this.showToast("SVG Generation Failed!");
                    console.error("SVG generation error:", err);
                }
            },
            generateTrueSVG() {
                const canvas = this.map.getCanvas();
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const style = getComputedStyle(document.documentElement);
                const oceanColor = style.getPropertyValue('--map-ocean').trim();
                const landColor = style.getPropertyValue('--map-land').trim();
                const borderColor = style.getPropertyValue('--map-border').trim();
                const accentColor = style.getPropertyValue('--accent-color').trim();
                const textColor = style.getPropertyValue('--ink').trim();
                const fontFamily = style.getPropertyValue('--font-family-sans').trim();
                let svgPaths = '';
                let svgMarkers = '';
                const features = this.map.queryRenderedFeatures({ layers: ['countries-fill-layer'] });
                const isFillActive = this.el.fillCountriesCheckbox.checked;
                features.forEach(feature => {
                    const countryCode = feature.properties.ADM0_A3;
                    const fillColor = (isFillActive && this.locatedCountryCodes.has(countryCode))
                        ? `rgba(${parseInt(accentColor.substr(1, 2), 16)}, ${parseInt(accentColor.substr(3, 2), 16)}, ${parseInt(accentColor.substr(5, 2), 16)}, 0.4)`
                        : landColor;
                    const geometry = feature.geometry;
                    let d = '';
                    const projectCoordsToPath = (coords) => {
                        let path = '';
                        coords.forEach((ring) => {
                            ring.forEach((point, j) => {
                                const p = this.map.project(point);
                                path += (j === 0) ? `M${p.x},${p.y}` : ` L${p.x},${p.y}`;
                            });
                            path += 'Z ';
                        });
                        return path;
                    };
                    if (geometry.type === 'Polygon') {
                        d = projectCoordsToPath(geometry.coordinates);
                    } else if (geometry.type === 'MultiPolygon') {
                        geometry.coordinates.forEach(polygon => { d += projectCoordsToPath(polygon); });
                    }
                    if (d) { svgPaths += `<path d="${d}" fill="${fillColor}" stroke="${borderColor}" stroke-width="0.5" />\n`; }
                });
                this.locationsData.forEach(loc => {
                    const p = this.map.project(loc.coords);
                    if (p.x >= 0 && p.y >= 0 && p.x <= width && p.y <= height) {
                        svgMarkers += `<circle cx="${p.x}" cy="${p.y}" r="4" fill="${accentColor}" stroke="#FFFFFF" stroke-width="1.5" />\n`;
                        svgMarkers += `<text x="${p.x + 8}" y="${p.y + 4}" class="label">${loc.label}</text>\n`;
                    }
                });
                return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg"><style>.label { font-family: ${fontFamily}; font-size: 10px; fill: ${textColor}; }</style><rect width="100%" height="100%" fill="${oceanColor}" /><g id="countries">${svgPaths}</g><g id="markers">${svgMarkers}</g></svg>`;
            },
            startGeocoding() {
                const value = this.el.locations.value;
                this.geocodeQueue = value.split(/;|\n/).map(s => s.trim()).filter(Boolean);
                if (this.geocodeQueue.length > 0) {
                    this.setLoadingState(true);
                    this.processNextInGeocodeQueue();
                    this.el.locations.value = '';
                }
            },
            processNextInGeocodeQueue() {
                if (this.geocodeQueue.length > 0) {
                    const nextLocation = this.geocodeQueue.shift();
                    setTimeout(() => this.handleLocationQuery(nextLocation), this.CONFIG.API_THROTTLE_MS);
                } else {
                    this.setLoadingState(false);
                }
            },
            async handleLocationQuery(locationName) {
                try {
                    const myAppUserAgent = 'Internal-LocatorTool/5.0-SingleFile (Internal Use; sporadic)';
                    const url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&limit=5&accept-language=en&q=${encodeURIComponent(locationName)}`;
                    const response = await fetch(url, { headers: { 'User-Agent': myAppUserAgent } });
                    if (!response.ok) throw new Error(`Geocoding error (${response.status})`);
                    const results = await response.json();
                    const seen = new Set();
                    const uniqueResults = results.filter(r => seen.has(r.display_name) ? false : seen.add(r.display_name));
                    if (uniqueResults.length === 0) {
                        this.renderUnfoundListItem(locationName);
                    } else if (uniqueResults.length === 1 || (uniqueResults[0].importance - uniqueResults[1].importance > 0.3)) {
                        this.placeLocation(uniqueResults[0]);
                    } else {
                        this.showAmbiguityPopup(uniqueResults, locationName);
                        return;
                    }
                } catch (error) {
                    console.error(`Error for "${locationName}":`, error);
                    this.renderUnfoundListItem(locationName, true);
                }
                this.processNextInGeocodeQueue();
            },
            placeLocation(result) {
                const markerId = Date.now();
                const labelText = result.display_name.split(',')[0];
                const coords = [parseFloat(result.lon), parseFloat(result.lat)];
                const countryA2 = result.address?.country_code?.toUpperCase();
                const countryA3 = this.isoLookup[countryA2];
                const marker = new maplibregl.Marker({ color: this.cssColors.accent, scale: 0.7 }).setLngLat(coords).addTo(this.map);
                const labelPopup = new maplibregl.Popup({ closeOnClick: false, closeButton: false, anchor: 'left', offset: 6 }).setLngLat(coords).setText(labelText).addTo(this.map);
                this.locationsData.push({ id: markerId, label: labelText, coords, countryCode: countryA3, mapMarker: marker, mapLabelPopup: labelPopup });
                if (countryA3) this.locatedCountryCodes.add(countryA3);
                this.renderListItem({ id: markerId, label: labelText });
                this.updateCountryFills();
            },
            renderListItem(data) {
                const li = document.createElement('li');
                li.dataset.markerId = data.id;
                li.innerHTML = `<span class="location-name">${data.label}</span><div class="location-controls"><button class="edit-btn" title="Edit">‚úèÔ∏è</button><button class="zoom-btn" title="Zoom To">üîç</button><button class="remove-btn" title="Remove">üóëÔ∏è</button></div>`;
                this.el.locationList.prepend(li);
            },
            renderUnfoundListItem(query, isError = false) {
                const li = document.createElement('li');
                li.classList.add('not-found');
                li.innerHTML = `<span class="location-name">"${query}" - ${isError ? 'Error' : 'Not found'}</span><div class="location-controls"><button class="remove-btn" title="Remove">üóëÔ∏è</button></div>`;
                this.el.locationList.prepend(li);
            },
            handleLocationListClick(e) {
                const button = e.target.closest('button');
                if (!button) return;
                const li = button.closest('li');
                const markerId = parseInt(li.dataset.markerId, 10);
                if (button.classList.contains('remove-btn')) {
                    if (markerId) {
                        const index = this.locationsData.findIndex(loc => loc.id === markerId);
                        if (index > -1) {
                            const [locData] = this.locationsData.splice(index, 1);
                            locData.mapMarker.remove();
                            locData.mapLabelPopup.remove();
                        }
                        li.remove();
                        this.recalculateLocatedCountries();
                        this.updateCountryFills();
                    } else {
                        li.remove();
                    }
                } else if (button.classList.contains('zoom-btn')) {
                    const locData = this.locationsData.find(loc => loc.id === markerId);
                    if (locData) this.map.flyTo({ center: locData.coords, zoom: 9 });
                } else if (button.classList.contains('edit-btn')) {
                    this.startEditLabel(li, markerId);
                }
            },
            startEditLabel(li, markerId) {
                const nameSpan = li.querySelector('.location-name');
                const currentLabel = nameSpan.textContent;

                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentLabel;
                input.className = 'edit-input';
                input.style.cssText = 'flex: 1; min-width: 0; padding: 4px 8px; font-size: 14px; border: 1px solid var(--accent-color); border-radius: var(--radius-sm); background: var(--surface); color: var(--ink);';

                nameSpan.replaceWith(input);
                input.focus();
                input.select();

                const saveEdit = () => {
                    const newLabel = input.value.trim() || currentLabel;
                    const span = document.createElement('span');
                    span.className = 'location-name';
                    span.textContent = newLabel;
                    input.replaceWith(span);

                    // Update data and map popup
                    const locData = this.locationsData.find(loc => loc.id === markerId);
                    if (locData) {
                        locData.label = newLabel;
                        locData.mapLabelPopup.setText(newLabel);
                    }
                };

                input.addEventListener('blur', saveEdit);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    } else if (e.key === 'Escape') {
                        input.value = currentLabel;
                        input.blur();
                    }
                });
            },
            updateCountryFills() {
                if (!this.map.isStyleLoaded() || !this.map.getLayer('countries-fill-layer')) return;
                const accent = this.cssColors.accent;
                const isChecked = this.el.fillCountriesCheckbox.checked;

                const fillColor = isChecked
                    ? ['case', ['in', ['get', 'ADM0_A3'], ['literal', [...this.locatedCountryCodes]]], accent, getComputedStyle(document.documentElement).getPropertyValue('--map-land').trim()]
                    : getComputedStyle(document.documentElement).getPropertyValue('--map-land').trim();

                this.map.setPaintProperty('countries-fill-layer', 'fill-color', fillColor);
            },
            recalculateLocatedCountries() {
                this.locatedCountryCodes.clear();
                this.locationsData.forEach(loc => { if (loc.countryCode) this.locatedCountryCodes.add(loc.countryCode); });
            },
            setLoadingState(isLoading) {
                this.el.generateBtn.disabled = isLoading;
                this.el.btnText.textContent = isLoading ? 'Adding...' : 'Add to Map';
                this.el.spinner.style.display = isLoading ? 'inline-block' : 'none';
            },
            showAmbiguityPopup(options, query) {
                this.ambiguityChoices = options;
                this.ambiguityOriginalQuery = query;
                this.el.ambiguityPopupMsg.textContent = `Multiple matches for "${query}":`;
                this.el.ambiguityPopupSelect.innerHTML = '';
                options.slice(0, 5).forEach((o, i) => this.el.ambiguityPopupSelect.add(new Option(o.display_name, String(i))));
                this.el.ambiguityPopupOverlay.classList.add('show');
            },
            resolveAmbiguity() {
                const sel = this.el.ambiguityPopupSelect.value;
                if (this.ambiguityChoices[sel]) this.placeLocation(this.ambiguityChoices[sel]);
                this.el.ambiguityPopupOverlay.classList.remove('show');
                this.processNextInGeocodeQueue();
            },
            skipAmbiguity() {
                this.renderUnfoundListItem(this.ambiguityOriginalQuery);
                this.el.ambiguityPopupOverlay.classList.remove('show');
                this.processNextInGeocodeQueue();
            },
            openWiki() {
                if (!this.el.wikiOverlay.querySelector('.wiki-modal-content')) {
                    const wikiModal = document.createElement('div');
                    wikiModal.className = 'wiki-modal-content';
                    wikiModal.innerHTML = `
                        <div class="wiki-header">
                          <h3 id="wiki-title">Info</h3>
                          <button id="wiki-close-btn" title="Close">√ó</button>
                        </div>
                        <div id="wiki-content"></div>`;
                    this.el.wikiOverlay.appendChild(wikiModal);
                    wikiModal.querySelector('#wiki-close-btn').addEventListener('click', () => this.closeWiki());
                }

                if (!this.isWikiLoaded) {
                    const titleEl = this.el.wikiOverlay.querySelector('#wiki-title');
                    const contentEl = this.el.wikiOverlay.querySelector('#wiki-content');
                    titleEl.textContent = WIKI_DATA.title;

                    const col1 = document.createElement('div'); col1.className = 'wiki-column';
                    const col2 = document.createElement('div'); col2.className = 'wiki-column';

                    WIKI_DATA.sections.forEach((s, index) => {
                        const sectionContainer = document.createElement('div');
                        const h4 = document.createElement('h4'); h4.textContent = s.title;
                        sectionContainer.appendChild(h4);
                        s.content.forEach(c => { const p = document.createElement('p'); p.innerHTML = c; sectionContainer.appendChild(p); });
                        if (index < 1) { col1.appendChild(sectionContainer); }
                        else { col2.appendChild(sectionContainer); }
                    });

                    contentEl.innerHTML = '';
                    contentEl.appendChild(col1);
                    contentEl.appendChild(col2);
                    this.isWikiLoaded = true;
                }
                this.el.wikiOverlay.classList.add('show');
            },
            closeWiki() { this.el.wikiOverlay.classList.remove('show'); },
            initTheme() {
                const savedTheme = localStorage.getItem('creative-toolkit-theme') || 'system';
                this.setTheme(savedTheme, false);
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
                    if (localStorage.getItem('creative-toolkit-theme') === 'system') this.applyTheme('system');
                });
            },
            setTheme(theme, save = true) {
                if (save) localStorage.setItem('creative-toolkit-theme', theme);
                this.el.themeToggle.textContent = this.THEME_ICONS[theme];
                this.applyTheme(theme);
            },
            cycleTheme() {
                const currentTheme = localStorage.getItem('creative-toolkit-theme') || 'system';
                const currentIndex = this.THEMES.indexOf(currentTheme);
                const nextTheme = this.THEMES[(currentIndex + 1) % this.THEMES.length];
                this.setTheme(nextTheme);
            },

            applyTheme(theme) {
                const isDark = (theme === 'system') ? window.matchMedia('(prefers-color-scheme: dark)').matches : theme === 'dark';
                document.documentElement.dataset.theme = isDark ? 'dark' : 'light';

                if (this.map && this.map.isStyleLoaded()) {
                    const style = getComputedStyle(document.documentElement);
                    this.map.setPaintProperty('background', 'background-color', style.getPropertyValue('--map-ocean').trim());
                    this.map.setPaintProperty('countries-border-layer', 'line-color', style.getPropertyValue('--map-border').trim());
                    this.updateCountryFills();
                }
            },
            showToast(message) {
                this.el.toast.textContent = message;
                this.el.toast.classList.add('show');
                setTimeout(() => this.el.toast.classList.remove('show'), 2000);
            },
        };
        App.init();
    </script>
</body>

</html>